spring: 
  rabbitmq: 
    host: 192.168.0.150
    # 端口,默认是5672
    port: 5672
    # 访问rabbitmq的用户名密码,默认都是guest,修改需要在rabbitmq的管理界面修改
    username: guest
    password: guest
    connection-timeout: 0
    # 开启生产者ACK机制
    # publisher-confirm-type: correlated
    # publisher-returns: true
    template:
      # 默认的交换机名称
      exchange: default-exchange
      # 发送者重试机制
      retry:
        # 开启重试
        enabled: true
        # 首次重试的间隔时间,单位ms
        initial-interval: 1000
        # 最大重试次数
        max-attempts: 3
        # 重试时间间隔,单位ms
        max-interval: 10000
        # 每次重试的因子,1表示上次的1倍,2上次的2倍
        multiplier: 1.0
    listener:
      simple:
        # Ack是否手动确认,manual手动,none不确认,auto自动,默认自动
        # 若在开启手动确认消息,则必须在消费者中手动确认消息,否则生产者会不停的发消息
#        acknowledge-mode: manual
        # 消费者数量
        concurrency: 10
        max-concurrency: 10
        # 每次从队列中取出的消息数
        prefetch: 1
        # 消费失败后立刻将消息重新发送到队列中,true->是,false->否
        default-requeue-rejected: true
        retry:
          # 是否开启重试机制,默认不开启
          enabled: true
          # 最大重试次数,默认3次
          max-attempts: 5
      direct:
        # NONE:不确认消息;AUTO:自动确认消息;MANUAL:手动确认消息
        acknowledge-mode: manual
        retry:
          enabled: true
          max-attempts: 5
  cloud:
    stream:
      # 若生产者开起了分区,消费者也可开启分区
      # 消费者总数
      instance-count: 2
      # 若有多个消费者,根据个数指定消费者的索引,从0开始
      instance-index: 0
      binders:
        defaultRabbit:
          type: rabbit
      bindings: 
        msgClient: 
          # 消息分组,若同名组中有多个消费者,只有组名相同的消费者会接收到生产者的消息
          group: test
          # 消息发送的目的地
          destination: testMsgClient
          producer:
            # 生产者分区,分区关键字
            partition-key-expression: payload
            # 分区大小
            partition-count: 2
          # 消费者开启分区
          consumer:
            partitioned: true